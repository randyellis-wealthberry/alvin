---
phase: 05-alvin-chat
plan: 03
type: execute
depends_on: ["05-02"]
files_modified: [src/lib/ai/prompts.ts, src/lib/ai/check-in-detection.ts, src/app/api/chat/route.ts, src/server/api/routers/conversation.ts, src/components/chat/ChatInterface.tsx, src/components/chat/CheckInBanner.tsx]
---

<objective>
Connect ALVIN Chat to the check-in system so conversations can complete wellness check-ins.

Purpose: The core value of ALVIN is confirming user wellness through natural conversation. This plan adds the detection logic to identify when a user has confirmed they're okay, and records a check-in when detected.
Output: Check-in detection from conversation content, automatic check-in recording, UI feedback showing check-in status, enhanced ALVIN prompts for check-in context.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-alvin-chat/05-RESEARCH.md
@.planning/phases/05-alvin-chat/05-01-SUMMARY.md
@.planning/phases/05-alvin-chat/05-02-SUMMARY.md
@.planning/phases/01-database-schema/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@prisma/schema.prisma
@src/lib/ai/prompts.ts
@src/app/api/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check-in detection logic</name>
  <files>src/lib/ai/check-in-detection.ts</files>
  <action>
Create src/lib/ai/check-in-detection.ts with simple phrase-based detection:

```typescript
/**
 * Detects if user messages indicate they are okay and can be checked in.
 *
 * Start simple with explicit phrases. Can add LLM-based detection later.
 * Per 05-RESEARCH.md open questions: "Start simple - explicit phrases trigger check-in"
 */

// Phrases that indicate user is okay (case-insensitive)
const CHECK_IN_PHRASES = [
  "i'm okay",
  "im okay",
  "i'm fine",
  "im fine",
  "i'm good",
  "im good",
  "i'm doing well",
  "im doing well",
  "doing great",
  "doing good",
  "all good",
  "all is well",
  "everything is fine",
  "everything's fine",
  "just checking in",
  "checking in",
  "i'm alright",
  "im alright",
  "feeling good",
  "feeling great",
  "feeling fine",
];

// Phrases that negate wellness (should NOT trigger check-in)
const NEGATION_PHRASES = [
  "not okay",
  "not fine",
  "not good",
  "not doing well",
  "not great",
  "not alright",
  "could be better",
  "been better",
  "struggling",
  "having a hard time",
  "stressed",
  "worried",
  "anxious",
  "depressed",
  "sad",
  "upset",
];

export interface CheckInDetectionResult {
  shouldCheckIn: boolean;
  confidence: "high" | "medium" | "low";
  matchedPhrase?: string;
}

export function detectCheckIn(userMessage: string): CheckInDetectionResult {
  const normalized = userMessage.toLowerCase().trim();

  // Check for negation first
  for (const phrase of NEGATION_PHRASES) {
    if (normalized.includes(phrase)) {
      return { shouldCheckIn: false, confidence: "high" };
    }
  }

  // Check for positive phrases
  for (const phrase of CHECK_IN_PHRASES) {
    if (normalized.includes(phrase)) {
      return {
        shouldCheckIn: true,
        confidence: "high",
        matchedPhrase: phrase,
      };
    }
  }

  return { shouldCheckIn: false, confidence: "low" };
}

/**
 * Analyzes a conversation to see if a check-in should be recorded.
 * Looks at the most recent user messages.
 */
export function analyzeConversationForCheckIn(
  messages: Array<{ role: string; content: string }>
): CheckInDetectionResult {
  // Get last 3 user messages (most relevant for check-in context)
  const recentUserMessages = messages
    .filter((m) => m.role === "user")
    .slice(-3);

  for (const msg of recentUserMessages) {
    const result = detectCheckIn(msg.content);
    if (result.shouldCheckIn) {
      return result;
    }
  }

  return { shouldCheckIn: false, confidence: "low" };
}
```

Keep detection simple for v1:
- Explicit phrase matching (not LLM-based)
- Negation detection to avoid false positives
- High confidence for exact matches
- Can upgrade to LLM-based detection in v2
  </action>
  <verify>
- `npm run typecheck` passes
- File exports detectCheckIn and analyzeConversationForCheckIn
  </verify>
  <done>Check-in detection with phrase matching and negation handling</done>
</task>

<task type="auto">
  <name>Task 2: Update API route to detect and record check-ins</name>
  <files>src/app/api/chat/route.ts</files>
  <action>
Update src/app/api/chat/route.ts to detect check-ins and record them:

```typescript
import { streamText, convertToModelMessages, type UIMessage } from 'ai';
import { alvinModel, MAX_TOKENS } from '~/lib/ai/config';
import { ALVIN_SYSTEM_PROMPT } from '~/lib/ai/prompts';
import { analyzeConversationForCheckIn } from '~/lib/ai/check-in-detection';
import { auth } from '~/server/auth';
import { db } from '~/server/db';

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user) {
    return new Response('Unauthorized', { status: 401 });
  }

  const { messages, conversationId }: {
    messages: UIMessage[];
    conversationId: string;
  } = await req.json();

  // Verify conversation ownership
  const profile = await db.userProfile.findUnique({
    where: { userId: session.user.id },
  });

  if (!profile) {
    return new Response('Profile not found', { status: 404 });
  }

  const conversation = await db.conversation.findUnique({
    where: {
      id: conversationId,
      userProfileId: profile.id,
    },
  });

  if (!conversation) {
    return new Response('Conversation not found', { status: 404 });
  }

  const result = streamText({
    model: alvinModel,
    system: ALVIN_SYSTEM_PROMPT,
    messages: await convertToModelMessages(messages),
    maxTokens: MAX_TOKENS,
  });

  // CRITICAL: Ensure stream completes even if client disconnects
  result.consumeStream();

  return result.toUIMessageStreamResponse({
    originalMessages: messages,
    onFinish: async ({ messages: finalMessages }) => {
      // Save messages
      const lastMessages = finalMessages.slice(-2);

      for (const msg of lastMessages) {
        const content = msg.parts
          .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
          .map(p => p.text)
          .join('');

        await db.message.create({
          data: {
            conversationId,
            role: msg.role,
            content,
          },
        });
      }

      // Update conversation timestamp
      await db.conversation.update({
        where: { id: conversationId },
        data: { updatedAt: new Date() },
      });

      // Check-in detection: analyze if user confirmed wellness
      const messagesForAnalysis = finalMessages.map((m) => ({
        role: m.role,
        content: m.parts
          .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
          .map(p => p.text)
          .join(''),
      }));

      const checkInResult = analyzeConversationForCheckIn(messagesForAnalysis);

      if (checkInResult.shouldCheckIn && !conversation.checkInId) {
        // Record check-in (conversation method)
        const checkIn = await db.checkIn.create({
          data: {
            userProfileId: profile.id,
            method: 'CONVERSATION',
          },
        });

        // Link conversation to check-in
        await db.conversation.update({
          where: { id: conversationId },
          data: { checkInId: checkIn.id },
        });

        // Update user's last check-in timestamp
        await db.userProfile.update({
          where: { id: profile.id },
          data: { lastCheckInAt: new Date() },
        });

        console.log(`Check-in recorded via conversation: ${checkIn.id}`);
      }
    },
  });
}
```

Key behavior:
- Analyze conversation after each message exchange
- Only record check-in once per conversation (check !conversation.checkInId)
- Use 'CONVERSATION' method for check-ins from chat
- Update userProfile.lastCheckInAt
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run build` succeeds
  </verify>
  <done>API route detects wellness confirmation and records check-in automatically</done>
</task>

<task type="auto">
  <name>Task 3: Add check-in status to conversation router and UI</name>
  <files>src/server/api/routers/conversation.ts, src/components/chat/ChatInterface.tsx, src/components/chat/CheckInBanner.tsx</files>
  <action>
Add getCheckInStatus procedure to src/server/api/routers/conversation.ts:

```typescript
// Add to existing router
getCheckInStatus: protectedProcedure
  .input(z.object({ conversationId: z.string() }))
  .query(async ({ ctx, input }) => {
    const profile = await ctx.db.userProfile.findUnique({
      where: { userId: ctx.session.user.id },
    });

    if (!profile) return { hasCheckIn: false };

    const conversation = await ctx.db.conversation.findUnique({
      where: {
        id: input.conversationId,
        userProfileId: profile.id,
      },
      include: { checkIn: true },
    });

    return {
      hasCheckIn: !!conversation?.checkIn,
      checkInAt: conversation?.checkIn?.performedAt,
    };
  }),
```

Create src/components/chat/CheckInBanner.tsx:

```typescript
"use client";

import { api } from "~/trpc/react";

interface CheckInBannerProps {
  conversationId: string;
}

export function CheckInBanner({ conversationId }: CheckInBannerProps) {
  const { data } = api.conversation.getCheckInStatus.useQuery(
    { conversationId },
    { refetchInterval: 5000 } // Poll for updates
  );

  if (!data?.hasCheckIn) return null;

  return (
    <div className="bg-green-50 border-b border-green-200 p-3 text-center">
      <span className="text-green-700 text-sm">
        âœ“ Check-in recorded
        {data.checkInAt && (
          <span className="text-green-600 ml-2">
            ({new Date(data.checkInAt).toLocaleString()})
          </span>
        )}
      </span>
    </div>
  );
}
```

Update src/components/chat/ChatInterface.tsx to show banner:

Add import:
```typescript
import { CheckInBanner } from "./CheckInBanner";
```

Add banner after header:
```typescript
<header className="flex items-center gap-4 border-b p-4">
  {/* ... existing header content ... */}
</header>

<CheckInBanner conversationId={conversationId} />
```

UI behavior:
- Banner shows when conversation has associated check-in
- Polls every 5 seconds for check-in status updates
- Green success color indicates wellness confirmed
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run build` succeeds
- CheckInBanner component renders conditionally
  </verify>
  <done>Check-in status displayed in UI, conversation shows when user has checked in</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Conversational check-in flow that records wellness confirmation</what-built>
  <how-to-verify>
    1. Run: `npm run dev`
    2. Visit: http://localhost:3000/chat
    3. Create a new conversation
    4. Have a brief conversation with ALVIN
    5. Send a message like "I'm doing great, thanks for checking in!"
    6. Verify:
       - Green "Check-in recorded" banner appears
       - Banner shows timestamp
    7. Check database (Prisma Studio):
       - Run: `npm run db:studio`
       - Check CheckIn table has new record with method='CONVERSATION'
       - Check Conversation has checkInId linked
    8. Refresh the page
    9. Verify:
       - Banner still shows (persisted)
       - Can continue chatting but no duplicate check-ins
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run check` passes (lint + typecheck)
- [ ] `npm run build` succeeds
- [ ] Check-in detection logic handles positive and negative phrases
- [ ] Check-in recorded in database when user confirms wellness
- [ ] Conversation linked to check-in (one check-in per conversation)
- [ ] UI banner shows check-in status
- [ ] Manual verification approved
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript or ESLint errors
- Wellness phrases trigger check-in recording
- Negative phrases do NOT trigger check-in
- UI provides clear feedback on check-in status
- Phase 5: ALVIN Chat complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-alvin-chat/05-03-SUMMARY.md`

This summary should note:
- Phase 5 is complete
- Ready for Phase 6 (Reminder System) or next milestone phase
</output>
