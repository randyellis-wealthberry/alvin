---
phase: 05-alvin-chat
plan: 02
type: execute
depends_on: ["05-01"]
files_modified: [src/server/api/routers/conversation.ts, src/server/api/root.ts, src/app/api/chat/route.ts, src/app/chat/page.tsx, src/components/chat/ChatInterface.tsx, src/app/chat/[conversationId]/page.tsx, src/components/chat/ConversationList.tsx]
---

<objective>
Add conversation persistence so chat history survives page refreshes and users can resume past conversations.

Purpose: Enable continuity in ALVIN conversations. Users can close the browser and return later to continue their wellness check-in conversation.
Output: tRPC router for conversation CRUD, messages persisted to database via onFinish callback, conversation list UI, ability to load and continue existing conversations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-alvin-chat/05-RESEARCH.md
@.planning/phases/05-alvin-chat/05-01-SUMMARY.md
@.planning/phases/01-database-schema/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@src/server/api/root.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation tRPC router</name>
  <files>src/server/api/routers/conversation.ts, src/server/api/root.ts</files>
  <action>
Create src/server/api/routers/conversation.ts with procedures:

```typescript
import { z } from "zod";
import { createTRPCRouter, protectedProcedure } from "~/server/api/trpc";

export const conversationRouter = createTRPCRouter({
  // Create a new conversation
  create: protectedProcedure
    .mutation(async ({ ctx }) => {
      // Get or create user profile (required for conversation)
      let profile = await ctx.db.userProfile.findUnique({
        where: { userId: ctx.session.user.id },
      });

      if (!profile) {
        profile = await ctx.db.userProfile.create({
          data: { userId: ctx.session.user.id },
        });
      }

      const conversation = await ctx.db.conversation.create({
        data: { userProfileId: profile.id },
      });

      return conversation;
    }),

  // Get all conversations for current user (most recent first)
  list: protectedProcedure
    .query(async ({ ctx }) => {
      const profile = await ctx.db.userProfile.findUnique({
        where: { userId: ctx.session.user.id },
      });

      if (!profile) return [];

      return ctx.db.conversation.findMany({
        where: { userProfileId: profile.id },
        orderBy: { updatedAt: "desc" },
        include: {
          messages: {
            take: 1,
            orderBy: { createdAt: "desc" },
          },
        },
      });
    }),

  // Get a single conversation with messages
  getById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const profile = await ctx.db.userProfile.findUnique({
        where: { userId: ctx.session.user.id },
      });

      if (!profile) return null;

      return ctx.db.conversation.findUnique({
        where: {
          id: input.id,
          userProfileId: profile.id, // Ensure user owns conversation
        },
        include: {
          messages: { orderBy: { createdAt: "asc" } },
        },
      });
    }),

  // Save messages to a conversation (called from API route)
  saveMessages: protectedProcedure
    .input(z.object({
      conversationId: z.string(),
      messages: z.array(z.object({
        role: z.enum(["user", "assistant"]),
        content: z.string(),
      })),
    }))
    .mutation(async ({ ctx, input }) => {
      const profile = await ctx.db.userProfile.findUnique({
        where: { userId: ctx.session.user.id },
      });

      if (!profile) throw new Error("Profile not found");

      // Verify ownership
      const conversation = await ctx.db.conversation.findUnique({
        where: {
          id: input.conversationId,
          userProfileId: profile.id,
        },
      });

      if (!conversation) throw new Error("Conversation not found");

      // Create messages
      await ctx.db.message.createMany({
        data: input.messages.map((msg) => ({
          conversationId: input.conversationId,
          role: msg.role,
          content: msg.content,
        })),
      });

      // Update conversation timestamp
      await ctx.db.conversation.update({
        where: { id: input.conversationId },
        data: { updatedAt: new Date() },
      });

      return { success: true };
    }),
});
```

Register in src/server/api/root.ts:
- Import conversationRouter
- Add to appRouter: `conversation: conversationRouter`

Follow existing router patterns from postRouter.
  </action>
  <verify>
- `npm run typecheck` passes
- conversationRouter exported and registered
- All procedures use protectedProcedure
  </verify>
  <done>Conversation router created with create, list, getById, saveMessages procedures</done>
</task>

<task type="auto">
  <name>Task 2: Update API route to persist messages via onFinish</name>
  <files>src/app/api/chat/route.ts</files>
  <action>
Update src/app/api/chat/route.ts to accept conversationId and persist messages:

```typescript
import { streamText, convertToModelMessages, type UIMessage } from 'ai';
import { alvinModel, MAX_TOKENS } from '~/lib/ai/config';
import { ALVIN_SYSTEM_PROMPT } from '~/lib/ai/prompts';
import { auth } from '~/server/auth';
import { db } from '~/server/db';

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user) {
    return new Response('Unauthorized', { status: 401 });
  }

  const { messages, conversationId }: {
    messages: UIMessage[];
    conversationId: string;
  } = await req.json();

  // Verify conversation ownership
  const profile = await db.userProfile.findUnique({
    where: { userId: session.user.id },
  });

  if (!profile) {
    return new Response('Profile not found', { status: 404 });
  }

  const conversation = await db.conversation.findUnique({
    where: {
      id: conversationId,
      userProfileId: profile.id,
    },
  });

  if (!conversation) {
    return new Response('Conversation not found', { status: 404 });
  }

  const result = streamText({
    model: alvinModel,
    system: ALVIN_SYSTEM_PROMPT,
    messages: await convertToModelMessages(messages),
    maxTokens: MAX_TOKENS,
  });

  // CRITICAL: Ensure stream completes even if client disconnects
  result.consumeStream();

  return result.toUIMessageStreamResponse({
    originalMessages: messages,
    onFinish: async ({ messages: finalMessages }) => {
      // Save the latest user + assistant message pair
      const lastMessages = finalMessages.slice(-2);

      for (const msg of lastMessages) {
        const content = msg.parts
          .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
          .map(p => p.text)
          .join('');

        await db.message.create({
          data: {
            conversationId,
            role: msg.role,
            content,
          },
        });
      }

      // Update conversation timestamp
      await db.conversation.update({
        where: { id: conversationId },
        data: { updatedAt: new Date() },
      });
    },
  });
}
```

Key pattern from research:
- `toUIMessageStreamResponse` with `originalMessages` and `onFinish` callback
- Extract text content from message parts (AI SDK uses structured parts)
- consumeStream() ensures onFinish fires even on disconnect
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run build` succeeds
- Route accepts conversationId in body
  </verify>
  <done>API route persists messages to database on stream completion</done>
</task>

<task type="auto">
  <name>Task 3: Update Chat UI to support conversation persistence</name>
  <files>src/app/chat/page.tsx, src/app/chat/[conversationId]/page.tsx, src/components/chat/ChatInterface.tsx, src/components/chat/ConversationList.tsx</files>
  <action>
Update src/app/chat/page.tsx to show conversation list and create new conversations:

```typescript
import { auth } from "~/server/auth";
import { redirect } from "next/navigation";
import { api, HydrateClient } from "~/trpc/server";
import { ConversationList } from "~/components/chat/ConversationList";

export default async function ChatPage() {
  const session = await auth();
  if (!session?.user) {
    redirect("/api/auth/signin");
  }

  // Prefetch conversations
  void api.conversation.list.prefetch();

  return (
    <HydrateClient>
      <main className="flex min-h-screen flex-col">
        <ConversationList />
      </main>
    </HydrateClient>
  );
}
```

Create src/components/chat/ConversationList.tsx:

```typescript
"use client";

import { useRouter } from "next/navigation";
import { api } from "~/trpc/react";

export function ConversationList() {
  const router = useRouter();
  const { data: conversations, isLoading } = api.conversation.list.useQuery();
  const createMutation = api.conversation.create.useMutation({
    onSuccess: (conversation) => {
      router.push(`/chat/${conversation.id}`);
    },
  });

  const handleNewConversation = () => {
    createMutation.mutate();
  };

  return (
    <div className="flex h-screen flex-col">
      <header className="flex items-center justify-between border-b p-4">
        <div>
          <h1 className="text-xl font-semibold">ALVIN</h1>
          <p className="text-sm text-gray-500">Your wellness companion</p>
        </div>
        <button
          onClick={handleNewConversation}
          disabled={createMutation.isPending}
          className="rounded-lg bg-blue-500 px-4 py-2 text-white hover:bg-blue-600 disabled:bg-gray-300"
        >
          New Chat
        </button>
      </header>

      <div className="flex-1 overflow-y-auto p-4">
        {isLoading && <p className="text-gray-500">Loading...</p>}

        {conversations?.length === 0 && (
          <div className="text-center text-gray-500 mt-8">
            <p>No conversations yet.</p>
            <p className="text-sm mt-2">Start a new chat with ALVIN!</p>
          </div>
        )}

        <div className="space-y-2">
          {conversations?.map((conv) => (
            <button
              key={conv.id}
              onClick={() => router.push(`/chat/${conv.id}`)}
              className="w-full rounded-lg border p-4 text-left hover:bg-gray-50"
            >
              <p className="font-medium">
                {conv.messages[0]?.content.slice(0, 50) || "New conversation"}
                {(conv.messages[0]?.content?.length ?? 0) > 50 ? "..." : ""}
              </p>
              <p className="text-sm text-gray-500">
                {new Date(conv.updatedAt).toLocaleDateString()}
              </p>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}
```

Create src/app/chat/[conversationId]/page.tsx:

```typescript
import { auth } from "~/server/auth";
import { redirect, notFound } from "next/navigation";
import { api } from "~/trpc/server";
import { ChatInterface } from "~/components/chat/ChatInterface";

interface PageProps {
  params: Promise<{ conversationId: string }>;
}

export default async function ConversationPage({ params }: PageProps) {
  const { conversationId } = await params;

  const session = await auth();
  if (!session?.user) {
    redirect("/api/auth/signin");
  }

  const conversation = await api.conversation.getById({ id: conversationId });
  if (!conversation) {
    notFound();
  }

  // Convert DB messages to initial messages format
  const initialMessages = conversation.messages.map((m) => ({
    id: m.id,
    role: m.role as "user" | "assistant",
    content: m.content,
  }));

  return (
    <main className="flex min-h-screen flex-col">
      <ChatInterface
        conversationId={conversationId}
        initialMessages={initialMessages}
      />
    </main>
  );
}
```

Update src/components/chat/ChatInterface.tsx to accept props:

```typescript
"use client";

import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import Link from "next/link";
import { MessageList } from "./MessageList";
import { MessageInput } from "./MessageInput";

interface ChatInterfaceProps {
  conversationId: string;
  initialMessages?: Array<{
    id: string;
    role: "user" | "assistant";
    content: string;
  }>;
}

export function ChatInterface({ conversationId, initialMessages = [] }: ChatInterfaceProps) {
  const { messages, sendMessage, status, error } = useChat({
    transport: new DefaultChatTransport({ api: "/api/chat" }),
    body: { conversationId },
    initialMessages: initialMessages.map((m) => ({
      id: m.id,
      role: m.role,
      parts: [{ type: "text" as const, text: m.content }],
      createdAt: new Date(),
    })),
  });

  const isLoading = status === "streaming" || status === "submitted";

  return (
    <div className="flex h-screen flex-col">
      <header className="flex items-center gap-4 border-b p-4">
        <Link href="/chat" className="text-blue-500 hover:underline">
          &larr; Back
        </Link>
        <div>
          <h1 className="text-xl font-semibold">ALVIN</h1>
          <p className="text-sm text-gray-500">Your wellness companion</p>
        </div>
      </header>

      <MessageList messages={messages} isLoading={isLoading} />

      {error && (
        <div className="border-t border-red-200 bg-red-50 p-3 text-sm text-red-600">
          {error.message}
        </div>
      )}

      <MessageInput onSend={sendMessage} disabled={isLoading} />
    </div>
  );
}
```

Key patterns:
- initialMessages prop loads existing conversation
- conversationId passed in body to API
- Conversation list shows preview of last message
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run build` succeeds
- Dynamic route created at /chat/[conversationId]
  </verify>
  <done>Chat UI supports loading existing conversations and creating new ones</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Conversation persistence with history and session continuity</what-built>
  <how-to-verify>
    1. Run: `npm run dev`
    2. Visit: http://localhost:3000/chat
    3. Click "New Chat" to create a conversation
    4. Send a few messages to ALVIN
    5. Refresh the page
    6. Verify:
       - Redirected back to /chat/[conversationId]
       - Previous messages still visible
       - Can continue the conversation
    7. Click "Back" to go to conversation list
    8. Verify:
       - Conversation appears in list with preview
       - Can click to re-enter conversation
    9. Create another conversation
    10. Verify both conversations appear in list
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run check` passes (lint + typecheck)
- [ ] `npm run build` succeeds
- [ ] Conversation router registered in appRouter
- [ ] Messages persisted to database
- [ ] Conversations loadable after page refresh
- [ ] Conversation list shows all user conversations
- [ ] Manual verification approved
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript or ESLint errors
- Conversations persist across page refreshes
- User can create and resume multiple conversations
- Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/05-alvin-chat/05-02-SUMMARY.md`
</output>
