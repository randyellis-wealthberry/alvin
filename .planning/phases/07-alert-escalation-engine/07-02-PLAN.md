---
phase: 07-alert-escalation-engine
plan: 02
type: execute
depends_on: ["07-01"]
files_modified:
  - src/server/api/routers/checkin.ts
  - src/server/api/routers/alert.ts
  - src/app/alerts/page.tsx
  - src/app/alerts/alert-list.tsx
  - src/app/page.tsx
---

<objective>
Add alert resolution on check-in and manual cancellation with UI.

Purpose: Complete the alert lifecycle by allowing alerts to be resolved (via check-in) or cancelled (manually).
Output: Auto-resolution on check-in, cancel mutation, and alerts page for viewing/cancelling.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-alert-escalation-engine/07-01-SUMMARY.md

# Existing implementations to modify/follow:
@src/server/api/routers/checkin.ts
@src/server/api/routers/alert.ts
@src/app/contacts/page.tsx
@src/app/contacts/contact-list.tsx

**Alert resolution rules:**
- Any check-in (MANUAL, BIOMETRIC, CONVERSATION) resolves active alerts
- Resolution sets: level = "RESOLVED", resolvedAt = now
- Only one active alert per user at a time (enforced by design)

**Alert cancellation rules:**
- User can cancel any active alert (LEVEL_1 through LEVEL_4)
- Cancellation sets: level = "CANCELLED", cancelledAt = now, cancelReason = optional
- Cancelled alerts stop escalation

**UI patterns (from contacts page):**
- SSR page component with Suspense
- Client component for list with actions
- Inline actions (no modal needed for cancel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-resolution on check-in</name>
  <files>src/server/api/routers/checkin.ts</files>
  <action>
Modify the checkIn.record mutation to resolve any active alert when user checks in.

After creating the check-in and updating lastCheckInAt, add:

1. Find active alert for profile:
   ```typescript
   const activeAlert = await ctx.db.alert.findFirst({
     where: {
       userProfileId: profile.id,
       level: { in: ["LEVEL_1", "LEVEL_2", "LEVEL_3", "LEVEL_4"] }
     }
   });
   ```

2. If active alert exists, resolve it:
   ```typescript
   if (activeAlert) {
     await ctx.db.alert.update({
       where: { id: activeAlert.id },
       data: {
         level: "RESOLVED",
         resolvedAt: now
       }
     });
   }
   ```

Add this to the existing transaction for atomicity.

Return the check-in as before (resolution is a side effect).
  </action>
  <verify>npm run typecheck passes, check-in creation includes alert resolution query</verify>
  <done>Check-in automatically resolves any active alert for the user</done>
</task>

<task type="auto">
  <name>Task 2: Add cancel mutation and alerts page</name>
  <files>src/server/api/routers/alert.ts, src/app/alerts/page.tsx, src/app/alerts/alert-list.tsx, src/app/page.tsx</files>
  <action>
**1. Add cancel mutation to alert router:**

```typescript
cancel: protectedProcedure
  .input(z.object({
    alertId: z.string(),
    reason: z.string().optional()
  }))
  .mutation(async ({ ctx, input }) => {
    // Get profile
    const profile = await ctx.db.userProfile.findUnique({
      where: { userId: ctx.session.user.id }
    });
    if (!profile) throw new TRPCError({ code: "NOT_FOUND" });

    // Find and validate alert belongs to user
    const alert = await ctx.db.alert.findFirst({
      where: {
        id: input.alertId,
        userProfileId: profile.id,
        level: { in: ["LEVEL_1", "LEVEL_2", "LEVEL_3", "LEVEL_4"] }
      }
    });
    if (!alert) throw new TRPCError({ code: "NOT_FOUND" });

    // Cancel alert
    return ctx.db.alert.update({
      where: { id: alert.id },
      data: {
        level: "CANCELLED",
        cancelledAt: new Date(),
        cancelReason: input.reason
      }
    });
  })
```

**2. Create alerts page (src/app/alerts/page.tsx):**

Follow contacts/page.tsx pattern:
- Server component with auth check (redirect to sign-in if not authenticated)
- Prefetch alert.list query
- Render AlertList client component in Suspense

**3. Create AlertList component (src/app/alerts/alert-list.tsx):**

"use client" component that:
- Uses api.alert.list.useQuery()
- Displays alerts in a list/table with:
  - Level badge (color-coded: L1=yellow, L2=orange, L3=red, L4=darkred, CANCELLED=gray, RESOLVED=green)
  - Triggered date (formatted)
  - Status indicator
- For active alerts (LEVEL_1-4), show Cancel button
- Cancel button calls api.alert.cancel.useMutation()
- After cancel, invalidate alert.list query
- Show empty state if no alerts

**4. Add Alerts link to home page navigation:**

Add link to /alerts in the navigation section of src/app/page.tsx, following the existing pattern for Contacts/Profile links.
  </action>
  <verify>npm run typecheck passes, npm run build succeeds, /alerts page renders</verify>
  <done>Users can view alerts, see their status, and cancel active alerts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm run lint` passes
- [ ] `npm run build` succeeds
- [ ] Check-in resolves active alert (test via tRPC or UI)
- [ ] /alerts page shows alert history
- [ ] Cancel button works for active alerts
- [ ] Navigation includes Alerts link
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Check-in automatically resolves alerts
- Users can view and cancel alerts from UI
- Phase 7 complete - escalation engine fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/07-alert-escalation-engine/07-02-SUMMARY.md` following the summary template.

Note in summary: "Phase 7 complete, ready for Phase 8 (Contact Notifications)"
</output>
