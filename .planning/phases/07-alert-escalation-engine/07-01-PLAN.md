---
phase: 07-alert-escalation-engine
plan: 01
type: execute
depends_on: []
files_modified:
  - src/lib/alerts/escalation.ts
  - src/server/api/routers/alert.ts
  - src/server/api/root.ts
  - src/app/api/cron/escalation/route.ts
  - vercel.json
---

<objective>
Build the alert escalation state machine that creates alerts for missed check-ins and escalates them through 4 levels.

Purpose: Implement the core "dead man's switch" logic that progresses alerts when users don't check in.
Output: Escalation module, alert router, and cron endpoint that automatically creates and escalates alerts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (reminder system patterns):
@.planning/phases/06-reminder-system/06-01-SUMMARY.md
@.planning/phases/06-reminder-system/06-02-SUMMARY.md

# Existing implementations to follow/extend:
@src/lib/reminders/eligibility.ts
@src/server/api/routers/checkin.ts
@src/app/api/cron/reminders/route.ts
@prisma/schema.prisma

**Escalation timeline (from PROJECT.md):**
- LEVEL_1: 24h after missed check-in (gentle reminder to user)
- LEVEL_2: 48h (second reminder to user)
- LEVEL_3: 72h (primary contact notified - Phase 8)
- LEVEL_4: 96h (all contacts notified - Phase 8)

**Alert model fields (from schema):**
- level: LEVEL_1 | LEVEL_2 | LEVEL_3 | LEVEL_4 | CANCELLED | RESOLVED
- triggeredAt: when alert was created
- lastEscalatedAt: when alert was last escalated
- resolvedAt: when user checked in
- cancelledAt: when user cancelled

**Established patterns:**
- Cron endpoint security: Bearer token matching CRON_SECRET
- Pure function eligibility calculation for testability
- Timezone-aware date calculations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation module with state transition logic</name>
  <files>src/lib/alerts/escalation.ts</files>
  <action>
Create escalation module following the eligibility.ts pattern (pure functions for testability).

Implement these functions:

1. `ESCALATION_THRESHOLDS` constant:
   - LEVEL_1: 24 hours (from missed check-in to L1 creation)
   - LEVEL_2: 24 hours (L1 to L2)
   - LEVEL_3: 24 hours (L2 to L3)
   - LEVEL_4: 24 hours (L3 to L4)

2. `getNextLevel(currentLevel: string): string | null`
   - LEVEL_1 → LEVEL_2
   - LEVEL_2 → LEVEL_3
   - LEVEL_3 → LEVEL_4
   - LEVEL_4 → null (terminal state)
   - CANCELLED/RESOLVED → null

3. `shouldCreateAlert(profile, existingAlerts): boolean`
   - Returns true if:
     - Profile is overdue (use calculateNextCheckInDue from eligibility)
     - No active alert exists (level not in CANCELLED/RESOLVED)

4. `shouldEscalate(alert, now: Date): boolean`
   - Returns true if time since lastEscalatedAt (or triggeredAt if null) exceeds threshold for current level
   - Returns false if level is LEVEL_4, CANCELLED, or RESOLVED

5. `findUsersNeedingAlerts(): Promise<UserNeedingAlert[]>`
   - Query active profiles with no active alerts
   - Filter to those overdue for check-in
   - Return user info for alert creation

6. `findAlertsNeedingEscalation(): Promise<Alert[]>`
   - Query alerts with level in LEVEL_1-3
   - Filter to those where shouldEscalate returns true

Import calculateNextCheckInDue from eligibility.ts to reuse timezone-aware logic.
  </action>
  <verify>npx tsc --noEmit passes, module exports all 6 items</verify>
  <done>Escalation module created with pure functions for alert creation and escalation decisions</done>
</task>

<task type="auto">
  <name>Task 2: Create alert tRPC router</name>
  <files>src/server/api/routers/alert.ts, src/server/api/root.ts</files>
  <action>
Create alert router following checkIn router patterns.

Implement procedures:

1. `list` (protectedProcedure.query):
   - Get user's profile
   - Return all alerts for profile ordered by triggeredAt desc
   - Include count of active vs resolved/cancelled

2. `getActive` (protectedProcedure.query):
   - Get user's profile
   - Return first alert where level is LEVEL_1-4 (not CANCELLED/RESOLVED)
   - Return null if no active alert

3. `create` (protectedProcedure.mutation):
   - Create alert at LEVEL_1 for user's profile
   - Set triggeredAt to now
   - Return created alert
   - Note: This is for internal use by cron, but exposed for testing

4. `escalate` (protectedProcedure.mutation):
   - Input: alertId
   - Validate alert belongs to user's profile
   - Get next level using getNextLevel
   - Update alert: level = nextLevel, lastEscalatedAt = now
   - Return updated alert
   - Note: For internal use by cron

Register router in root.ts as `alert: alertRouter`.
  </action>
  <verify>npm run typecheck passes, router registered in root.ts</verify>
  <done>Alert router created with list, getActive, create, escalate procedures</done>
</task>

<task type="auto">
  <name>Task 3: Add escalation cron endpoint</name>
  <files>src/app/api/cron/escalation/route.ts, vercel.json</files>
  <action>
Create escalation cron endpoint following reminders cron pattern.

GET /api/cron/escalation:

1. Validate Authorization header (Bearer CRON_SECRET)
2. Call findUsersNeedingAlerts()
3. For each user needing alert:
   - Create alert at LEVEL_1
   - Log creation
4. Call findAlertsNeedingEscalation()
5. For each alert needing escalation:
   - Get next level
   - Update alert with new level and lastEscalatedAt
   - Log escalation
6. Return JSON response:
   ```json
   {
     "success": true,
     "alertsCreated": N,
     "alertsEscalated": N,
     "timestamp": "ISO string"
   }
   ```

Update vercel.json to add hourly cron for escalation:
- Add entry for "/api/cron/escalation" with schedule "0 * * * *" (hourly, same as reminders)

Note: Contact notifications (L3/L4) will be added in Phase 8. This phase just escalates the levels.
  </action>
  <verify>curl with valid Bearer token returns success response, vercel.json has both cron entries</verify>
  <done>Escalation cron creates alerts for overdue users and escalates existing alerts through levels</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm run lint` passes
- [ ] `npm run build` succeeds
- [ ] Alert router registered and accessible via tRPC
- [ ] Escalation cron endpoint returns 401 without auth, 200 with auth
- [ ] vercel.json has both /api/cron/reminders and /api/cron/escalation
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Escalation logic correctly calculates thresholds (24h per level)
- Cron endpoint creates and escalates alerts
</success_criteria>

<output>
After completion, create `.planning/phases/07-alert-escalation-engine/07-01-SUMMARY.md` following the summary template.
</output>
