---
phase: 16-convex-realtime
plan: 03
type: execute
depends_on: ["16-02"]
files_modified: [src/app/dashboard/status-widget.tsx, src/app/dashboard/page.tsx]
---

<objective>
Add real-time status updates and polish the dashboard with live indicators.

Purpose: Make the status widget show live alert status and last check-in time that updates without refresh. Add visual indicators showing real-time connection status.
Output: Dashboard with live-updating status, real-time connection indicator, complete Phase 16.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-convex-realtime/16-01-SUMMARY.md
@.planning/phases/16-convex-realtime/16-02-SUMMARY.md

# Files to modify:
@src/app/dashboard/status-widget.tsx
@src/app/dashboard/page.tsx

# Convex queries from Plan 01:
@convex/alerts.ts

**Pattern:** Same Convex/tRPC dual-source pattern as activity log
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add real-time status to StatusWidget</name>
  <files>src/app/dashboard/status-widget.tsx</files>
  <action>
Enhance StatusWidget to use Convex for real-time status updates:

1. Import Convex hooks and API:
   ```typescript
   import { useQuery as useConvexQuery } from "convex/react";
   import { api as convexApi } from "~/convex/_generated/api";
   ```

2. Add Convex query alongside existing tRPC:
   - Use `useConvexQuery(convexApi.alerts.getUserStatus, { userId })`
   - Pass "skip" as args when userId not available

3. Merge data sources:
   - Convex provides: lastCheckIn, nextDue, alertLevel, alertTriggeredAt
   - tRPC provides: same data but via polling
   - Use Convex when available, tRPC fallback when not

4. Map Convex timestamps (numbers) to Date objects for display:
   ```typescript
   const status = convexStatus ? {
     lastCheckIn: convexStatus.lastCheckIn ? new Date(convexStatus.lastCheckIn) : null,
     nextDue: convexStatus.nextDue ? new Date(convexStatus.nextDue) : null,
     alertLevel: convexStatus.alertLevel,
     // ... etc
   } : trpcStatus;
   ```

5. Handle loading state: Convex useQuery returns undefined while loading.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Status widget shows real-time status from Convex</done>
</task>

<task type="auto">
  <name>Task 2: Add real-time connection indicator</name>
  <files>src/app/dashboard/page.tsx</files>
  <action>
Add a subtle visual indicator showing real-time connection status:

1. Import Convex connection state hook:
   ```typescript
   import { useConvex } from "convex/react";
   ```

2. Check connection state (the ConvexReactClient tracks this internally):
   - When Convex configured and connected: Show green "Live" indicator
   - When Convex not configured: Show nothing (graceful absence)
   - When disconnected/reconnecting: Show yellow "Reconnecting..." briefly

3. Add small indicator near the dashboard header:
   ```tsx
   {convexUrl && (
     <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
       <span className="h-2 w-2 rounded-full bg-green-500 animate-pulse" />
       <span>Live</span>
     </div>
   )}
   ```

4. The indicator should be unobtrusive - small, in the corner or near the title.
   Use Shadcn-compatible styling (muted-foreground for text, proper colors).

Note: Full connection state tracking requires checking if queries are loading vs connected.
A simpler approach: just show "Live" when Convex URL is configured (indicates real-time mode is active).
  </action>
  <verify>npm run build passes, indicator visible on dashboard when Convex configured</verify>
  <done>Dashboard shows live indicator when real-time is active</done>
</task>

<task type="auto">
  <name>Task 3: Integration test and cleanup</name>
  <files>src/app/dashboard/page.tsx, src/app/dashboard/status-widget.tsx, src/app/dashboard/activity-log.tsx</files>
  <action>
Final integration verification and cleanup:

1. Verify all imports resolve correctly:
   - Check that `~/convex/_generated/api` imports work
   - If not generated, ensure `npx convex dev` has been run

2. Ensure consistent error handling:
   - All Convex queries should handle undefined (loading) state
   - All sync operations should catch errors

3. Remove any console.log debugging statements added during development.

4. Ensure the dashboard works in both modes:
   - WITH Convex: Real-time updates, live indicator shown
   - WITHOUT Convex: Falls back to tRPC polling, no live indicator

5. Verify TypeScript types are correct:
   - No `any` types that could be properly typed
   - Convex query return types properly handled

6. Run full verification:
   - npm run typecheck
   - npm run build
   - npm run lint (if quick, fix any issues)
  </action>
  <verify>npm run build && npm run typecheck both pass</verify>
  <done>Dashboard fully integrated with real-time, types clean, no regressions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run typecheck` passes
- [ ] Status widget shows real-time data from Convex
- [ ] Live indicator visible when Convex configured
- [ ] Dashboard works without Convex (graceful fallback)
- [ ] No TypeScript errors or `any` types
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Dashboard fully real-time when Convex configured
- Phase 16 complete
</success_criteria>

<output>
After completion, create `.planning/phases/16-convex-realtime/16-03-SUMMARY.md`
</output>
