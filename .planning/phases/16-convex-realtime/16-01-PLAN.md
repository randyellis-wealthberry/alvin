---
phase: 16-convex-realtime
plan: 01
type: execute
depends_on: []
files_modified: [convex/schema.ts, convex/activities.ts, convex/alerts.ts, src/lib/convex/sync.ts]
---

<objective>
Set up Convex schema for real-time dashboard data and create sync utilities.

Purpose: Establish the data model and write-through sync mechanism to populate Convex with activity/alert data from Prisma after each write operation.
Output: Convex schema with activities/alerts tables, sync utility functions, indexed queries for efficient real-time reads.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing Convex setup:
@convex/schema.ts
@convex/tasks.ts
@src/components/convex-provider.tsx

# Current dashboard data sources:
@src/server/api/routers/dashboard.ts
@src/app/dashboard/activity-log.tsx

# Prisma schema for reference:
@prisma/schema.prisma

**Tech available:** Convex 1.31.5, ConvexProvider already configured
**Pattern:** Write-through sync - Prisma remains source of truth, Convex provides real-time reads
**Constraint:** Must work without NEXT_PUBLIC_CONVEX_URL configured (graceful degradation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Convex schema for activities and alerts</name>
  <files>convex/schema.ts</files>
  <action>
Replace the example tasks table with production schema:

1. `activities` table:
   - `userId: v.string()` - NextAuth user ID (not Convex ID)
   - `type: v.union(v.literal("check-in"), v.literal("alert"), v.literal("conversation"))`
   - `description: v.string()`
   - `timestamp: v.number()` - Unix timestamp ms
   - `metadata: v.optional(v.any())` - Flexible JSON for type-specific data
   - Index: `by_user_timestamp` on ["userId", "timestamp"] for efficient user queries
   - Index: `by_timestamp` on ["timestamp"] for global ordering

2. `userStatus` table (singleton per user):
   - `userId: v.string()`
   - `lastCheckIn: v.optional(v.number())` - Unix timestamp
   - `nextDue: v.optional(v.number())` - Unix timestamp
   - `alertLevel: v.optional(v.union(v.literal("L1"), v.literal("L2"), v.literal("L3"), v.literal("L4"), v.null_()))`
   - `alertTriggeredAt: v.optional(v.number())`
   - Index: `by_user` on ["userId"] for lookup

Do NOT use v.id() references to Prisma tables - keep schemas independent.
  </action>
  <verify>npx convex dev shows schema accepted without errors</verify>
  <done>Schema defines activities and userStatus tables with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create Convex query functions for real-time reads</name>
  <files>convex/activities.ts, convex/alerts.ts</files>
  <action>
Create query functions for dashboard consumption:

**convex/activities.ts:**
- `getRecentActivities` query: Takes userId (string) and limit (optional, default 20). Query activities table with by_user_timestamp index, filter by userId, order by timestamp desc, take limit. Return array of activity documents.
- `addActivity` mutation: Takes userId, type, description, timestamp, optional metadata. Insert into activities table. Return the new document ID.

**convex/alerts.ts:**
- `getUserStatus` query: Takes userId (string). Query userStatus with by_user index. Return document or null.
- `updateUserStatus` mutation: Takes userId and partial status fields (lastCheckIn, nextDue, alertLevel, alertTriggeredAt). Upsert: if exists patch, else insert. Use ctx.db.query().withIndex().unique() to find existing.

All functions use proper argument validation with v.* validators.
Remove the example tasks.ts file after creating these.
  </action>
  <verify>npx convex dev shows functions registered, no type errors</verify>
  <done>Query and mutation functions created for activities and userStatus</done>
</task>

<task type="auto">
  <name>Task 3: Create sync utility for write-through pattern</name>
  <files>src/lib/convex/sync.ts</files>
  <action>
Create a utility module for syncing Prisma writes to Convex:

```typescript
// src/lib/convex/sync.ts
import { ConvexHttpClient } from "convex/browser";
import { api } from "~/convex/_generated/api";

// Server-side Convex client (for tRPC routers)
const convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL;
const convex = convexUrl ? new ConvexHttpClient(convexUrl) : null;

export async function syncActivity(data: {
  userId: string;
  type: "check-in" | "alert" | "conversation";
  description: string;
  timestamp: Date;
  metadata?: Record<string, unknown>;
}) {
  if (!convex) return; // Graceful skip if Convex not configured

  await convex.mutation(api.activities.addActivity, {
    userId: data.userId,
    type: data.type,
    description: data.description,
    timestamp: data.timestamp.getTime(),
    metadata: data.metadata,
  });
}

export async function syncUserStatus(data: {
  userId: string;
  lastCheckIn?: Date;
  nextDue?: Date;
  alertLevel?: "L1" | "L2" | "L3" | "L4" | null;
  alertTriggeredAt?: Date | null;
}) {
  if (!convex) return;

  await convex.mutation(api.alerts.updateUserStatus, {
    userId: data.userId,
    lastCheckIn: data.lastCheckIn?.getTime(),
    nextDue: data.nextDue?.getTime(),
    alertLevel: data.alertLevel,
    alertTriggeredAt: data.alertTriggeredAt?.getTime(),
  });
}
```

Import ConvexHttpClient from "convex/browser" (works server-side).
Handle undefined convex client gracefully (when NEXT_PUBLIC_CONVEX_URL not set).
  </action>
  <verify>npm run typecheck passes, imports resolve correctly</verify>
  <done>Sync utility exists with type-safe functions for activity and status sync</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev` runs without errors
- [ ] `npm run typecheck` passes
- [ ] Schema has activities and userStatus tables with indexes
- [ ] Query functions (getRecentActivities, getUserStatus) exist
- [ ] Mutation functions (addActivity, updateUserStatus) exist
- [ ] Sync utility handles missing Convex URL gracefully
</verification>

<success_criteria>

- All tasks completed
- Convex schema deployed successfully
- Sync utility ready to be called from tRPC routers
- Example tasks.ts removed, production schema in place
</success_criteria>

<output>
After completion, create `.planning/phases/16-convex-realtime/16-01-SUMMARY.md`
</output>
