---
phase: 16-convex-realtime
plan: 02
type: execute
depends_on: ["16-01"]
files_modified: [src/app/dashboard/activity-log.tsx, src/server/api/routers/checkin.ts, src/server/api/routers/alert.ts]
---

<objective>
Integrate Convex real-time subscriptions into the activity log and wire up sync on writes.

Purpose: Replace tRPC polling with Convex real-time subscriptions for the activity log. Add sync calls after check-ins and alert changes so Convex stays updated.
Output: Activity log that updates in real-time without page refresh. Write operations sync to Convex.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-convex-realtime/16-01-SUMMARY.md

# Files to modify:
@src/app/dashboard/activity-log.tsx
@src/server/api/routers/checkin.ts
@src/server/api/routers/alert.ts

# Sync utility from Plan 01:
@src/lib/convex/sync.ts

# Convex API (will be generated):
# @convex/_generated/api

**Constraint:** Must gracefully fallback to tRPC when Convex not configured
**Pattern:** Check if NEXT_PUBLIC_CONVEX_URL is set, use Convex or tRPC accordingly
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sync calls to check-in router</name>
  <files>src/server/api/routers/checkin.ts</files>
  <action>
After successful check-in operations, sync to Convex:

1. Import sync utilities at top: `import { syncActivity, syncUserStatus } from "~/lib/convex/sync";`

2. In the `performCheckIn` mutation (or similar check-in procedure):
   - After Prisma write succeeds, call syncActivity with:
     - userId: ctx.session.user.id
     - type: "check-in"
     - description: Generated description (e.g., "Biometric check-in completed" or "Manual check-in")
     - timestamp: new Date()
   - Also call syncUserStatus with:
     - userId: ctx.session.user.id
     - lastCheckIn: new Date()
     - nextDue: calculated next due date
     - alertLevel: null (check-in clears alerts)

3. Use try/catch around sync calls - don't let Convex failures break the main operation.
   Log errors but don't throw (Convex is enhancement, not critical path).

Pattern:
```typescript
// After successful Prisma write
try {
  await syncActivity({...});
  await syncUserStatus({...});
} catch (e) {
  console.error("Convex sync failed (non-critical):", e);
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Check-in operations sync activity and status to Convex</done>
</task>

<task type="auto">
  <name>Task 2: Add sync calls to alert router</name>
  <files>src/server/api/routers/alert.ts</files>
  <action>
After alert state changes, sync to Convex:

1. Import sync utilities: `import { syncActivity, syncUserStatus } from "~/lib/convex/sync";`

2. In the escalation/alert trigger procedures:
   - After creating or escalating an alert, call syncActivity with:
     - type: "alert"
     - description: Alert-level specific message (e.g., "Alert escalated to Level 2")
   - Call syncUserStatus with:
     - alertLevel: the new level ("L1", "L2", "L3", "L4")
     - alertTriggeredAt: alert.triggeredAt

3. In alert cancellation procedure:
   - Call syncActivity with description: "Alert cancelled"
   - Call syncUserStatus with:
     - alertLevel: null
     - alertTriggeredAt: null

4. Wrap all sync calls in try/catch - failures should not break alert operations.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Alert operations sync to Convex</done>
</task>

<task type="auto">
  <name>Task 3: Replace activity log with Convex real-time subscription</name>
  <files>src/app/dashboard/activity-log.tsx</files>
  <action>
Modify ActivityLog to use Convex for real-time updates with tRPC fallback:

1. Add imports:
   ```typescript
   import { useQuery as useConvexQuery } from "convex/react";
   import { api as convexApi } from "~/convex/_generated/api";
   ```

2. Create a hook or conditional logic:
   - Check if Convex is available: `const convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL;`
   - If available, use `useConvexQuery(convexApi.activities.getRecentActivities, { userId, limit: 20 })`
   - If not available, keep existing tRPC query

3. The Convex query returns data in a different shape (Convex document format):
   - Map Convex data to match existing ActivityItem interface
   - Handle timestamp conversion (Convex stores as number, UI expects Date)

4. Implementation pattern:
   ```typescript
   // Get session for userId
   const { data: session } = useSession();

   // Convex real-time (if configured)
   const convexActivities = useConvexQuery(
     convexApi.activities.getRecentActivities,
     session?.user?.id ? { userId: session.user.id, limit: 20 } : "skip"
   );

   // tRPC fallback
   const { data: trpcActivities, isLoading: trpcLoading } = api.dashboard.getActivityLog.useQuery(
     { limit: 20 },
     { enabled: !convexUrl } // Only fetch if Convex not configured
   );

   // Use Convex data if available, else tRPC
   const activities = convexActivities ?? trpcActivities;
   const isLoading = convexUrl ? convexActivities === undefined : trpcLoading;
   ```

5. Note: useConvexQuery returns undefined while loading, then data. No separate isLoading flag.
  </action>
  <verify>npm run build passes, dev server shows activity log loading</verify>
  <done>Activity log uses Convex real-time with tRPC fallback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run typecheck` passes
- [ ] Check-in syncs activity + status to Convex
- [ ] Alert changes sync to Convex
- [ ] Activity log renders with real-time data (when Convex configured)
- [ ] Activity log falls back to tRPC (when Convex not configured)
</verification>

<success_criteria>

- All tasks completed
- Check-in and alert routers sync to Convex
- Activity log subscribes to real-time updates
- Graceful degradation when Convex not configured
</success_criteria>

<output>
After completion, create `.planning/phases/16-convex-realtime/16-02-SUMMARY.md`
</output>
