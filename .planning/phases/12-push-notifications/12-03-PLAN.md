---
phase: 12-push-notifications
plan: 03
type: execute
depends_on: ["12-02"]
files_modified: [src/components/push/PushPermissionPrompt.tsx, src/components/push/index.ts, src/app/dashboard/page.tsx]
---

<objective>
Create push permission prompt UI and integrate into dashboard for user opt-in.

Purpose: Give users clear control over push notifications with a two-step permission flow that explains value before requesting browser permission.
Output: Dashboard shows push prompt for users without subscriptions. Users can enable/disable push with clear feedback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-push-notifications/12-RESEARCH.md
@.planning/phases/12-push-notifications/12-CONTEXT.md
@.planning/phases/12-push-notifications/12-02-SUMMARY.md (after Plan 02 completes)
@src/app/dashboard/page.tsx
@src/components/pwa/InstallPrompt.tsx (reference for component patterns)

**From Research:**
- CRITICAL: Two-step permission flow (custom prompt THEN browser prompt)
- If user blocks browser permission, can never ask again
- Check Notification.permission before showing prompt

**From Context:**
- Easy to enable/disable (user control)
- Simple on/off (no granular preferences)
- Clear messaging - explain value, not just "enable notifications"

**Key client-side helper (from research):**
```typescript
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  const rawData = atob(base64);
  return Uint8Array.from(rawData, char => char.charCodeAt(0));
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PushPermissionPrompt component with two-step flow</name>
  <files>src/components/push/PushPermissionPrompt.tsx, src/components/push/index.ts</files>
  <action>
Create src/components/push/ directory with:

**PushPermissionPrompt.tsx:**
A client component ("use client") with two-step permission flow:

1. **Check permission state on mount:**
   - If `Notification.permission === 'denied'`: Show "blocked" state with instructions
   - If `Notification.permission === 'granted'`: Check subscription status via api.push.getStatus
   - If user already subscribed: Show "enabled" toggle to disable
   - Otherwise: Show prompt to enable

2. **Two-step enable flow:**
   - Step 1: Custom ALVIN prompt explaining value
     - Title: "Stay Connected with ALVIN"
     - Body: "Get notified about check-in reminders and important alerts. Push notifications ensure you never miss a check-in."
     - Buttons: "Enable Notifications" / "Maybe Later"
   - Step 2: If user clicks "Enable", call Notification.requestPermission()
   - Step 3: If granted, subscribe via service worker and call api.push.subscribe

3. **Subscription flow (after permission granted):**
   ```typescript
   const registration = await navigator.serviceWorker.ready;
   const subscription = await registration.pushManager.subscribe({
     userVisibleOnly: true,
     applicationServerKey: urlBase64ToUint8Array(
       process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
     )
   });
   const json = subscription.toJSON();
   await api.push.subscribe.mutate({
     endpoint: json.endpoint!,
     p256dh: json.keys!.p256dh,
     auth: json.keys!.auth,
     userAgent: navigator.userAgent,
   });
   ```

4. **Disable flow:**
   - Unsubscribe from push manager
   - Call api.push.unsubscribe with endpoint

5. **States to handle:**
   - Loading (checking status)
   - Not prompted yet (show enable prompt)
   - Permission denied (show instructions to unblock)
   - Enabled (show toggle to disable)
   - Error (show retry)

**Styling:**
- Match ALVIN design (purple accents, clean layout)
- Use existing Tailwind patterns from other components
- Card-like container with clear call-to-action

**index.ts:**
```typescript
export { PushPermissionPrompt } from './PushPermissionPrompt';
```

**AVOID:**
- Don't request browser permission without custom prompt first (two-step is critical)
- Don't use localStorage for dismissed state (user should always be able to enable later)
- Don't show prompt if service worker not available
  </action>
  <verify>
- `npm run typecheck` passes
- Component exports from src/components/push/index.ts
- Component handles all permission states
  </verify>
  <done>PushPermissionPrompt component with two-step flow, all permission states handled</done>
</task>

<task type="auto">
  <name>Task 2: Add push prompt to dashboard</name>
  <files>src/app/dashboard/page.tsx</files>
  <action>
Import and add PushPermissionPrompt to the dashboard page:

1. Import the component:
   ```typescript
   import { PushPermissionPrompt } from "~/components/push";
   ```

2. Add to dashboard layout, positioned after the main activity content:
   - Wrap in a card/section with subtle styling
   - Only render on client (service worker check)
   - Position below activity log or in a sidebar depending on existing layout

3. Check if service worker API is available before rendering:
   ```typescript
   {typeof window !== 'undefined' && 'serviceWorker' in navigator && (
     <PushPermissionPrompt />
   )}
   ```

**AVOID:**
- Don't make push prompt the primary focus (it's secondary to main dashboard content)
- Don't hide it completely either (users should easily find it)
  </action>
  <verify>
- `npm run build` succeeds
- Dashboard page includes push prompt
- Prompt only shows when service worker available
  </verify>
  <done>Push permission prompt integrated into dashboard, visible but not intrusive</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Push notification permission flow and dashboard integration</what-built>
  <how-to-verify>
1. Run: `npm run dev:pwa` (service worker requires non-Turbopack build)
2. Visit: http://localhost:3000/dashboard (logged in)
3. Verify push prompt appears on dashboard
4. Click "Enable Notifications"
5. Confirm browser permission prompt appears (second step)
6. Grant permission
7. Verify success state shows in UI
8. Check: Open browser DevTools > Application > Push (subscription should exist)
9. Test: Click "Send Test" if available, or use api.push.testNotification via tRPC panel
10. Confirm notification appears on desktop

**Note:** Push notifications require HTTPS in production but work on localhost for testing.
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run typecheck` passes
- [ ] PushPermissionPrompt component exists and exports correctly
- [ ] Dashboard includes push prompt
- [ ] Two-step permission flow works (custom prompt â†’ browser prompt)
- [ ] Subscription successfully stored in database
- [ ] Test notification received on device
</verification>

<success_criteria>

- All tasks completed including human verification
- All verification checks pass
- No errors or warnings introduced
- Users can enable push notifications from dashboard
- Push infrastructure end-to-end functional
- Phase 12 complete
</success_criteria>

<output>
After completion, create `.planning/phases/12-push-notifications/12-03-SUMMARY.md`
</output>
